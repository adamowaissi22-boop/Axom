local Ropoto = loadstring(game:HttpGet("https://raw.githubusercontent.com/adamowaissi22-boop/Axom-Scripts-/refs/heads/main/Ropoto%20Ui%20Library%20Script"))()

local Window = Ropoto:CreateWindow("99 Nights At The Forest Script - Axomic 99 Nights Hub")

local player = game.Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ProximityPromptService = game:GetService("ProximityPromptService")
local TeleportService = game:GetService("TeleportService")
local VirtualUser = game:GetService("VirtualUser")
local Stats = game:GetService("Stats")
local MarketplaceService = game:GetService("MarketplaceService")

local savedCFrame = nil
local amountToBring = 1
local selectedValues = {
    child = "Choose",
    bringItem = "Choose",
    entityType = "Choose"
}

local function getHRP()
    local char = player.Character
    if char then
        return char:FindFirstChild("HumanoidRootPart")
    end
end

local function safeTeleport(target)
    local hrp = getHRP()
    if hrp and target then
        local cframe
        if target:IsA("Model") and target.PrimaryPart then
            cframe = target.PrimaryPart.CFrame
        elseif target:IsA("BasePart") then
            cframe = target.CFrame
        elseif typeof(target) == "CFrame" then
            cframe = target
        elseif typeof(target) == "Vector3" then
            cframe = CFrame.new(target)
        end
        if cframe then
            hrp.CFrame = cframe + Vector3.new(0, 5, 0)
        end
    end
end

local function DragItem(instance)
    local hrp = getHRP()
    if not hrp or not instance or not instance.PrimaryPart then return end
    instance:SetPrimaryPartCFrame(hrp.CFrame * CFrame.new(0, 2, 0))
end

local inputValues = {}
local Main = Window:MakeSection("Main")

Main:MakeButton("Teleport To Campground", function()
    local map = Workspace:FindFirstChild("Map")
    if map then
        local campground = map:FindFirstChild("Campground")
        if campground then
            local mainFire = campground:FindFirstChild("MainFire")
            if mainFire then
                safeTeleport(mainFire)
                Window:MakeNotification("Success", "Teleported to MainFire", 3)
            else
                Window:MakeNotification("Error", "MainFire not found in Campground", 3)
            end
        else
            Window:MakeNotification("Error", "Campground not found in Map", 3)
        end
    else
        Window:MakeNotification("Error", "Map not found in workspace", 3)
    end
end)

Main:MakeButton("Save Place", function()
    local hrp = getHRP()
    if hrp then
        savedCFrame = hrp.CFrame
        Window:MakeNotification("Saved Place", "Current location saved!", 3)
    end
end)

Main:MakeButton("Teleport To Saved Place", function()
    if savedCFrame then
        local hrp = getHRP()
        if hrp then
            hrp.CFrame = savedCFrame
            Window:MakeNotification("Teleported", "Teleported to saved place!", 3)
        end
    end
end)

Main:MakeBox("Player Name", "Write here player name or first 3 letters", function(value)
    inputValues.playerName = value:lower()
end)

Main:MakeButton("Kill Player", function()
    local input = inputValues.playerName or ""
    if input == "" then return end
    task.spawn(function()
        for _, plr in pairs(game.Players:GetPlayers()) do
            if plr ~= player and plr.Name:lower():sub(1,#input) == input then
                local targetHRP = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
                if targetHRP then
                    for _, trap in pairs(Workspace:FindFirstChild("Structures") and Workspace.Structures:GetChildren() or {}) do
                        if trap.Name == "Bear Trap" and trap:IsA("Model") and trap.PrimaryPart then
                            trap:SetPrimaryPartCFrame(targetHRP.CFrame * CFrame.new(0,2,0))
                            task.wait(0.1)
                        end
                    end
                    for _, trap in pairs(Workspace:FindFirstChild("Structure") and Workspace.Structure:GetChildren() or {}) do
                        if trap.Name == "Bear Trap" and trap:IsA("Model") and trap.PrimaryPart then
                            trap:SetPrimaryPartCFrame(targetHRP.CFrame * CFrame.new(0,2,0))
                            task.wait(0.1)
                        end
                    end
                end
            end
        end
    end)
end)

local Children = Window:MakeSection("Missing Children")
local childItems = {"Child","Child 2","Child 3","Child 4"}
Children:MakeDropdown("Choose Child", childItems, function(selectedChild)
    selectedValues.child = selectedChild
end)
Children:MakeButton("Teleport To Selected Child", function()
    if selectedValues.child ~= "Choose" then
        local target = Workspace:FindFirstChild("Characters") and Workspace.Characters:FindFirstChild(selectedValues.child)
        if target then 
            safeTeleport(target)
            Window:MakeNotification("Teleporting", "Teleporting to "..selectedValues.child, 2)
        else
            Window:MakeNotification("Error", selectedValues.child.." not found!", 3)
        end
    else
        Window:MakeNotification("Error", "Please select a child first!", 3)
    end
end)

local Bring = Window:MakeSection("Bring")
Bring:MakeBox("Amount To Bring", "Enter number", function(value)
    local n = tonumber(value)
    if n and n >= 1 then 
        amountToBring = math.floor(n) 
    else 
        amountToBring = 1 
    end
end)

local itemNames = {"Choose","Log","Sapling"}
if Workspace:FindFirstChild("Items") then
    for _,v in pairs(Workspace.Items:GetChildren()) do
        if not table.find(itemNames, v.Name) then
            table.insert(itemNames, v.Name)
        end
    end
end

Bring:MakeDropdown("Choose Item To Bring", itemNames, function(selectedItem)
    selectedValues.bringItem = selectedItem
end)

Bring:MakeButton("Bring Selected Item", function()
    if selectedValues.bringItem ~= "Choose" then
        task.spawn(function()
            local movedCount = 0
            for _, Obj in pairs(Workspace.Items:GetChildren()) do
                if Obj.Name == selectedValues.bringItem and Obj:IsA("Model") and Obj.PrimaryPart then
                    DragItem(Obj)
                    movedCount += 1
                    if movedCount >= amountToBring then break end
                    task.wait(0.08)
                end
            end
            Window:MakeNotification("Bring Complete", "Brought "..movedCount.." "..selectedValues.bringItem.."(s)", 3)
        end)
    else
        Window:MakeNotification("Error", "Please select an item first!", 3)
    end
end)

local Auto = Window:MakeSection("Auto")
local autoTeleportEnabled = false
local healthThreshold = 30
Auto:MakeToggle("Auto Teleport to Campground when Health Low", false, function(enabled)
    autoTeleportEnabled = enabled
end)
Auto:MakeSlider("If Health Less Than", 10, 100, 30, function(value)
    healthThreshold = value
end)
Auto:MakeButton("Fill Fire With Logs", function()
    local map = Workspace:FindFirstChild("Map")
    if map then
        local campground = map:FindFirstChild("Campground")
        if campground then
            local mainFire = campground:FindFirstChild("MainFire")
            if mainFire then
                for _, log in pairs(Workspace.Items:GetChildren()) do
                    if log.Name == "Log" and log:IsA("Model") then
                        ReplicatedStorage.RemoteEvents.RequestBurnItem:FireServer(mainFire, log)
                        task.wait(0.1)
                    end
                end
                Window:MakeNotification("Success", "Filled fire with logs", 3)
            else
                Window:MakeNotification("Error", "MainFire not found", 3)
            end
        else
            Window:MakeNotification("Error", "Campground not found", 3)
        end
    else
        Window:MakeNotification("Error", "Map not found", 3)
    end
end)

local CharacterControl = Window:MakeSection("Character Control")
local entityTypes = {"Choose"}
if Workspace:FindFirstChild("Characters") then
    local foundTypes = {}
    for _, char in pairs(Workspace.Characters:GetChildren()) do
        if char:IsA("Model") and not foundTypes[char.Name] then
            foundTypes[char.Name] = true
            table.insert(entityTypes, char.Name)
        end
    end
end
CharacterControl:MakeDropdown("Choose entity type", entityTypes, function(selectedType)
    selectedValues.entityType = selectedType
end)
CharacterControl:MakeButton("Bring Entity", function()
    if selectedValues.entityType ~= "Choose" then
        local hrp = getHRP()
        if hrp then
            for _, char in pairs(Workspace.Characters:GetChildren()) do
                if char.Name == selectedValues.entityType and char:IsA("Model") and char.PrimaryPart then
                    char:SetPrimaryPartCFrame(hrp.CFrame * CFrame.new(0,0,5))
                end
            end
            Window:MakeNotification("Success", "Brought all "..selectedValues.entityType, 3)
        end
    else
        Window:MakeNotification("Error", "Please select an entity type first!", 3)
    end
end)
CharacterControl:MakeButton("Bring Entity Loot If Dead", function()
    if selectedValues.entityType ~= "Choose" then
        local hrp = getHRP()
        if hrp then
            for _, char in pairs(Workspace.Characters:GetChildren()) do
                if char.Name == selectedValues.entityType and char:IsA("Model") then
                    local humanoid = char:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health <= 0 then
                        for _, part in pairs(char:GetDescendants()) do
                            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                                part.CFrame = hrp.CFrame * CFrame.new(0,2,0)
                            end
                        end
                    end
                end
            end
            Window:MakeNotification("Success", "Brought loot from dead "..selectedValues.entityType, 3)
        end
    else
        Window:MakeNotification("Error", "Please select an entity type first!", 3)
    end
end)

local PlayerEnhancements = Window:MakeSection("Player Enhancements")
local walkSpeed = 16
local jumpPower = 50
local flyEnabled = false
local flySpeed = 1
local infiniteJump = false
local noclipEnabled = false
local godModeEnabled = false
local antiVoidEnabled = false
local antiAFKEnabled = false
local noFogEnabled = false
local fullBrightEnabled = false
local fpsBoostEnabled = false
local noclipConnection = nil
local godModeThread = nil
local antiVoidPart = nil
local antiVoidConnection = nil
local antiAFKConnection = nil
local noFogThread = nil
local fullBrightThread = nil
local flyThread = nil
local flyKeys = {W = 0, A = 0, S = 0, D = 0, E = 0, Q = 0}
local fpsBoostData = {
    enabled = false,
    lighting = {},
    decals = {},
    particles = {},
    postFx = {},
}
local touchEnabled = UserInputService.TouchEnabled
local bodyGyro = nil
local bodyVelocity = nil
local flyConnection = nil
local humanoid = nil

local function getHumanoid()
    if player.Character then
        return player.Character:FindFirstChildOfClass("Humanoid")
    end
    return nil
end

local function getHumanoidRootPart()
    if player.Character then
        return player.Character:FindFirstChild("HumanoidRootPart")
    end
    return nil
end

local function cleanFlyParts()
    local hrp = getHumanoidRootPart()
    if hrp then
        for _, child in pairs(hrp:GetChildren()) do
            if child:IsA("BodyGyro") or child:IsA("BodyVelocity") then
                child:Destroy()
            end
        end
    end
    local hum = getHumanoid()
    if hum then
        hum.PlatformStand = false
        hum:ChangeState(Enum.HumanoidStateType.GettingUp)
    end
end

local function startTouchFly()
    cleanFlyParts()
    flyEnabled = true
    
    local hrp = getHumanoidRootPart()
    local hum = getHumanoid()
    if not hrp or not hum then return end
    
    local controlModule = require(player.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(9000000000, 9000000000, 9000000000)
    bodyVelocity.Velocity = Vector3.zero
    bodyVelocity.Parent = hrp
    
    bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(9000000000, 9000000000, 9000000000)
    bodyGyro.D = 50
    bodyGyro.P = 1000
    bodyGyro.Parent = hrp
    hum.PlatformStand = true
    
    flyConnection = RunService.RenderStepped:Connect(function()
        if flyEnabled and hrp and hum and bodyVelocity and bodyGyro then
            local moveVector = controlModule:GetMoveVector()
            bodyGyro.CFrame = Workspace.CurrentCamera.CFrame
            
            if moveVector.Magnitude <= 0 then
                bodyVelocity.Velocity = Vector3.zero
            else
                bodyVelocity.Velocity = (Workspace.CurrentCamera.CFrame.RightVector * moveVector.X - Workspace.CurrentCamera.CFrame.LookVector * moveVector.Z) * (flySpeed * 50)
            end
        end
    end)
end

local function startDesktopFly()
    cleanFlyParts()
    flyEnabled = true
    
    local hrp = getHumanoidRootPart()
    local hum = getHumanoid()
    if not hrp or not hum then return end
    
    bodyGyro = Instance.new("BodyGyro")
    bodyVelocity = Instance.new("BodyVelocity")
    bodyGyro.P = 90000
    bodyGyro.MaxTorque = Vector3.new(9000000000, 9000000000, 9000000000)
    bodyGyro.CFrame = hrp.CFrame
    bodyGyro.Parent = hrp
    
    bodyVelocity.MaxForce = Vector3.new(9000000000, 9000000000, 9000000000)
    bodyVelocity.Velocity = Vector3.zero
    bodyVelocity.Parent = hrp
    hum.PlatformStand = true
    
    local inputBeganConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed then
            if input.KeyCode == Enum.KeyCode.W then flyKeys.W = flySpeed
            elseif input.KeyCode == Enum.KeyCode.S then flyKeys.S = -flySpeed
            elseif input.KeyCode == Enum.KeyCode.A then flyKeys.A = -flySpeed
            elseif input.KeyCode == Enum.KeyCode.D then flyKeys.D = flySpeed
            elseif input.KeyCode == Enum.KeyCode.E then flyKeys.E = flySpeed * 2
            elseif input.KeyCode == Enum.KeyCode.Q then flyKeys.Q = -flySpeed * 2 end
        end
    end)
    
    local inputEndedConnection = UserInputService.InputEnded:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.W then flyKeys.W = 0
        elseif input.KeyCode == Enum.KeyCode.S then flyKeys.S = 0
        elseif input.KeyCode == Enum.KeyCode.A then flyKeys.A = 0
        elseif input.KeyCode == Enum.KeyCode.D then flyKeys.D = 0
        elseif input.KeyCode == Enum.KeyCode.E then flyKeys.E = 0
        elseif input.KeyCode == Enum.KeyCode.Q then flyKeys.Q = 0 end
    end)
    
    flyConnection = RunService.RenderStepped:Connect(function()
        if flyEnabled and hrp and hum and bodyVelocity and bodyGyro then
            local camera = Workspace.CurrentCamera
            bodyGyro.CFrame = camera.CFrame
            
            if Vector3.new(flyKeys.A + flyKeys.D, flyKeys.Q + flyKeys.E, flyKeys.W + flyKeys.S).Magnitude <= 0 then
                bodyVelocity.Velocity = Vector3.zero
            else
                bodyVelocity.Velocity = (camera.CFrame.LookVector * (flyKeys.W + flyKeys.S) + 
                                       camera.CFrame.RightVector * (flyKeys.A + flyKeys.D) + 
                                       camera.CFrame.UpVector * (flyKeys.Q + flyKeys.E)) * (flySpeed * 50)
            end
        else
            if flyConnection then flyConnection:Disconnect() flyConnection = nil end
            if inputBeganConnection then inputBeganConnection:Disconnect() end
            if inputEndedConnection then inputEndedConnection:Disconnect() end
        end
    end)
end

local function stopFly()
    flyEnabled = false
    flyKeys = {W = 0, A = 0, S = 0, D = 0, E = 0, Q = 0}
    
    if flyConnection then
        flyConnection:Disconnect()
        flyConnection = nil
    end
    
    cleanFlyParts()
end

PlayerEnhancements:MakeSlider("Walk Speed", 16, 300, 16, function(value)
    walkSpeed = value
    local char = player.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = walkSpeed
        end
    end
end)

PlayerEnhancements:MakeSlider("Jump Power", 50, 350, 50, function(value)
    jumpPower = value
    local char = player.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.JumpPower = jumpPower
        end
    end
end)

PlayerEnhancements:MakeToggle("Fly", false, function(enabled)
    if enabled then
        if touchEnabled then
            startTouchFly()
        else
            startDesktopFly()
        end
        Window:MakeNotification("Fly Enabled", "Press E to ascend, Q to descend, WASD to move", 5)
    else
        stopFly()
        Window:MakeNotification("Fly Disabled", "Flight mode deactivated", 3)
    end
end)

PlayerEnhancements:MakeSlider("Fly Speed", 1, 5, 1, function(value)
    flySpeed = value
    if flyEnabled then
        if touchEnabled then
            stopFly()
            startTouchFly()
        else
            flyKeys.W = flyKeys.W > 0 and flySpeed or 0
            flyKeys.S = flyKeys.S < 0 and -flySpeed or 0
            flyKeys.A = flyKeys.A < 0 and -flySpeed or 0
            flyKeys.D = flyKeys.D > 0 and flySpeed or 0
            flyKeys.E = flyKeys.E > 0 and flySpeed * 2 or 0
            flyKeys.Q = flyKeys.Q < 0 and -flySpeed * 2 or 0
        end
    end
end)

PlayerEnhancements:MakeToggle("Infinite Jump", false, function(enabled)
    infiniteJump = enabled
end)

UserInputService.JumpRequest:Connect(function()
    if infiniteJump and getHumanoid() then
        getHumanoid():ChangeState("Jumping")
    end
end)

PlayerEnhancements:MakeToggle("NoClip", false, function(enabled)
    noclipEnabled = enabled
    if enabled then
        Window:MakeNotification("NoClip Enabled", "You can now walk through walls", 3)
        noclipConnection = game:GetService("RunService").Stepped:Connect(function()
            if player.Character then
                for _, part in pairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        if player.Character then
            for _, part in pairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
        Window:MakeNotification("NoClip Disabled", "Collision restored", 3)
    end
end)

PlayerEnhancements:MakeToggle("God Mode", false, function(enabled)
    godModeEnabled = enabled
    if enabled then
        Window:MakeNotification("God Mode Enabled", "Damage protection active", 3)
        godModeThread = task.spawn(function()
            while godModeEnabled do
                pcall(function()
                    ReplicatedStorage.RemoteEvents.DamagePlayer:FireServer(-math.huge)
                end)
                task.wait(1)
            end
        end)
    else
        if godModeThread then
            task.cancel(godModeThread)
            godModeThread = nil
        end
        Window:MakeNotification("God Mode Disabled", "Normal damage restored", 3)
    end
end)

PlayerEnhancements:MakeToggle("Anti Void", false, function(enabled)
    antiVoidEnabled = enabled
    if enabled then
        antiVoidPart = Instance.new("Part")
        antiVoidPart.Anchored = true
        antiVoidPart.CanCollide = true
        antiVoidPart.Transparency = 1
        antiVoidPart.Name = "Axom_AntiVoid"
        antiVoidPart.Size = Vector3.new(2038, 1, 1971)
        antiVoidPart.CFrame = CFrame.new(119.466187, -109.710114, 107.103119)
        antiVoidPart.Parent = Workspace
        
        antiVoidConnection = antiVoidPart.Touched:Connect(function(touchedPart)
            local char = player.Character
            if char and touchedPart:IsDescendantOf(char) then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.CFrame = CFrame.new(0, 20, 0)
                    Window:MakeNotification("Anti Void", "Teleported back to campfire", 3)
                end
            end
        end)
        Window:MakeNotification("Anti Void Enabled", "Invisible platform created", 3)
    else
        if antiVoidConnection then
            antiVoidConnection:Disconnect()
            antiVoidConnection = nil
        end
        if antiVoidPart and antiVoidPart.Parent then
            antiVoidPart:Destroy()
            antiVoidPart = nil
        end
        Window:MakeNotification("Anti Void Disabled", "Platform removed", 3)
    end
end)

PlayerEnhancements:MakeToggle("Anti AFK", false, function(enabled)
    antiAFKEnabled = enabled
    if enabled then
        local VirtualUser = game:GetService("VirtualUser")
        antiAFKConnection = player.Idled:Connect(function()
            if antiAFKEnabled then
                VirtualUser:Button2Down(Vector2.new(0, 0), Workspace.CurrentCamera.CFrame)
                task.wait(1)
                VirtualUser:Button2Up(Vector2.new(0, 0), Workspace.CurrentCamera.CFrame)
            end
        end)
        Window:MakeNotification("Anti AFK Enabled", "You won't be kicked for idling", 3)
    else
        if antiAFKConnection then
            antiAFKConnection:Disconnect()
            antiAFKConnection = nil
        end
        Window:MakeNotification("Anti AFK Disabled", "Idle prevention stopped", 3)
    end
end)

PlayerEnhancements:MakeToggle("No Fog", false, function(enabled)
    noFogEnabled = enabled
    if enabled then
        noFogThread = task.spawn(function()
            while noFogEnabled do
                game.Lighting.FogEnd = 10000
                game.Lighting.FogStart = 10000
                task.wait(1)
            end
        end)
        Window:MakeNotification("No Fog Enabled", "Far view enabled", 3)
    else
        if noFogThread then
            task.cancel(noFogThread)
            noFogThread = nil
        end
        game.Lighting.FogEnd = 1000
        game.Lighting.FogStart = 0
        Window:MakeNotification("No Fog Disabled", "Default fog restored", 3)
    end
end)

PlayerEnhancements:MakeToggle("Full Bright", false, function(enabled)
    fullBrightEnabled = enabled
    if enabled then
        fullBrightThread = task.spawn(function()
            while fullBrightEnabled do
                local colorCorrection = game.Lighting:FindFirstChildOfClass("ColorCorrectionEffect")
                if colorCorrection then
                    colorCorrection.Enabled = false
                end
                game.Lighting.Brightness = 3
                game.Lighting.ClockTime = 12
                task.wait(1)
            end
        end)
        Window:MakeNotification("Full Bright Enabled", "Bright visuals activated", 3)
    else
        if fullBrightThread then
            task.cancel(fullBrightThread)
            fullBrightThread = nil
        end
        local colorCorrection = game.Lighting:FindFirstChildOfClass("ColorCorrectionEffect")
        if colorCorrection then
            colorCorrection.Enabled = true
        end
        game.Lighting.Brightness = 2
        Window:MakeNotification("Full Bright Disabled", "Color correction restored", 3)
    end
end)

PlayerEnhancements:MakeToggle("FPS Boost", false, function(enabled)
    fpsBoostEnabled = enabled
    if enabled then
        fpsBoostData.enabled = true
        fpsBoostData.lighting.Brightness = game.Lighting.Brightness
        fpsBoostData.lighting.GlobalShadows = game.Lighting.GlobalShadows
        fpsBoostData.lighting.EnvironmentDiffuseScale = game.Lighting.EnvironmentDiffuseScale
        fpsBoostData.lighting.EnvironmentSpecularScale = game.Lighting.EnvironmentSpecularScale
        fpsBoostData.lighting.OutdoorAmbient = game.Lighting.OutdoorAmbient
        
        game.Lighting.Brightness = 1
        game.Lighting.GlobalShadows = false
        game.Lighting.EnvironmentDiffuseScale = 0
        game.Lighting.EnvironmentSpecularScale = 0
        game.Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
        
        for _, effect in pairs(game.Lighting:GetDescendants()) do
            if effect:IsA("BloomEffect") or effect:IsA("SunRaysEffect") or effect:IsA("ColorCorrectionEffect") or 
               effect:IsA("DepthOfFieldEffect") or effect:IsA("BlurEffect") then
                fpsBoostData.postFx[effect] = effect.Enabled
                effect.Enabled = false
            end
        end
        
        local function processModel(model)
            for _, descendant in pairs(model:GetDescendants()) do
                if descendant:IsA("Decal") or descendant:IsA("Texture") then
                    if fpsBoostData.decals[descendant] == nil then
                        fpsBoostData.decals[descendant] = descendant.Transparency
                        descendant.Transparency = 1
                    end
                elseif (descendant:IsA("ParticleEmitter") or descendant:IsA("Trail") or descendant:IsA("Smoke") or 
                       descendant:IsA("Fire") or descendant:IsA("Sparkles")) then
                    if fpsBoostData.particles[descendant] == nil then
                        fpsBoostData.particles[descendant] = descendant.Enabled
                        descendant.Enabled = false
                    end
                end
            end
        end
        
        processModel(Workspace)
        processModel(game.Lighting)
        Window:MakeNotification("FPS Boost Enabled", "Visuals optimized for performance", 3)
    else
        if fpsBoostData.enabled then
            fpsBoostData.enabled = false
            
            if fpsBoostData.lighting.Brightness ~= nil then
                game.Lighting.Brightness = fpsBoostData.lighting.Brightness
            end
            if fpsBoostData.lighting.GlobalShadows ~= nil then
                game.Lighting.GlobalShadows = fpsBoostData.lighting.GlobalShadows
            end
            if fpsBoostData.lighting.EnvironmentDiffuseScale ~= nil then
                game.Lighting.EnvironmentDiffuseScale = fpsBoostData.lighting.EnvironmentDiffuseScale
            end
            if fpsBoostData.lighting.EnvironmentSpecularScale ~= nil then
                game.Lighting.EnvironmentSpecularScale = fpsBoostData.lighting.EnvironmentSpecularScale
            end
            if fpsBoostData.lighting.OutdoorAmbient ~= nil then
                game.Lighting.OutdoorAmbient = fpsBoostData.lighting.OutdoorAmbient
            end
            
            for effect, enabled in pairs(fpsBoostData.postFx) do
                if effect and effect.Parent then
                    effect.Enabled = enabled
                end
            end
            
            for decal, transparency in pairs(fpsBoostData.decals) do
                if decal and decal.Parent then
                    decal.Transparency = transparency
                end
            end
            
            for particle, enabled in pairs(fpsBoostData.particles) do
                if particle and particle.Parent then
                    particle.Enabled = enabled
                end
            end
            
            fpsBoostData = {
                enabled = false,
                lighting = {},
                decals = {},
                particles = {},
                postFx = {},
            }
            Window:MakeNotification("FPS Boost Disabled", "Visuals restored", 3)
        end
    end
end)

local CombatFeatures = Window:MakeSection("Combat Features")
local killAuraEnabled = false
local killAuraRadius = 75
local killAuraCooldown = 0.5
local killAuraThread = nil
local lastAttackTimes = {}
local autoStunEnabled = false
local autoStunThread = nil

local function getBestWeapon()
    local inventory = player:FindFirstChild("Inventory")
    if not inventory then return nil end
    
    local bestWeapon = nil
    local highestDamage = 0
    
    for _, item in pairs(inventory:GetChildren()) do
        local damage = item:GetAttribute("WeaponDamage")
        if typeof(damage) == "number" and damage > highestDamage then
            highestDamage = damage
            bestWeapon = item
        end
    end
    
    return bestWeapon
end

local function equipWeapon(weapon)
    if weapon then
        pcall(function()
            ReplicatedStorage.RemoteEvents.EquipItemHandle:FireServer("FireAllClients", weapon)
        end)
    end
end

CombatFeatures:MakeToggle("Kill Aura", false, function(enabled)
    killAuraEnabled = enabled
    if enabled then
        Window:MakeNotification("Kill Aura", "Enabled - radius " .. killAuraRadius .. " studs", 3)
        killAuraThread = task.spawn(function()
            while killAuraEnabled do
                local char = player.Character
                if char then
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local bestWeapon = getBestWeapon()
                        if bestWeapon then
                            equipWeapon(bestWeapon)
                        end
                        
                        local currentTime = tick()
                        local nearbyParts = Workspace:GetPartBoundsInRadius(hrp.Position, killAuraRadius)
                        for _, part in pairs(nearbyParts) do
                            local model = part:FindFirstAncestorOfClass("Model")
                            if model and model ~= char then
                                local humanoid = model:FindFirstChildOfClass("Humanoid")
                                local targetHRP = model:FindFirstChild("HumanoidRootPart")
                                if humanoid and targetHRP and humanoid.Health > 0 then
                                    local lastAttackTime = lastAttackTimes[model] or 0
                                    if currentTime - lastAttackTime >= killAuraCooldown then
                                        lastAttackTimes[model] = currentTime
                                        task.spawn(function()
                                            pcall(function()
                                                ReplicatedStorage.RemoteEvents.ToolDamageObject:InvokeServer(model, bestWeapon, "1_" .. player.UserId, targetHRP.CFrame)
                                            end)
                                        end)
                                    end
                                end
                            end
                        end
                    end
                end
                task.wait(killAuraCooldown)
            end
        end)
    else
        if killAuraThread then
            task.cancel(killAuraThread)
            killAuraThread = nil
        end
        lastAttackTimes = {}
        Window:MakeNotification("Kill Aura", "Disabled", 3)
    end
end)

CombatFeatures:MakeSlider("Kill Aura Range", 10, 100, 75, function(value)
    killAuraRadius = value
    Window:MakeNotification("Kill Aura", "Range set to " .. killAuraRadius, 3)
end)

CombatFeatures:MakeToggle("Auto Stun Monsters", false, function(enabled)
    autoStunEnabled = enabled
    if enabled then
        Window:MakeNotification("Auto Stun", "Enabled - stunning deer/owl/ram", 3)
        autoStunThread = task.spawn(function()
            while autoStunEnabled do
                local characters = Workspace:FindFirstChild("Characters")
                if characters then
                    for _, monsterName in pairs({"Deer", "Owl", "Ram"}) do
                        local monster = characters:FindFirstChild(monsterName)
                        if monster and monster:IsA("Model") and monster:FindFirstChild("HumanoidRootPart") then
                            pcall(function()
                                ReplicatedStorage.RemoteEvents.MonsterHitByTorch:InvokeServer(monster)
                            end)
                            task.wait(0.3)
                        end
                    end
                end
                task.wait(1)
            end
        end)
    else
        if autoStunThread then
            task.cancel(autoStunThread)
            autoStunThread = nil
        end
        Window:MakeNotification("Auto Stun", "Disabled", 3)
    end
end)

local AutoFeatures = Window:MakeSection("Auto Features")
local autoChopEnabled = false
local autoChopRadius = 75
local autoChopThread = nil
local autoChopTreeType = "All Trees"
local treeHealthBars = {}
local autoReviveEnabled = false
local autoReviveItem = "Both"
local autoReviveThread = nil
local autoPotionsEnabled = false
local autoBuySeedsEnabled = false
local autoPotionsThread = nil
local autoFuelFireEnabled = false
local autoFuelTypes = {"All"}
local autoFuelThread = nil
local autoScrapperEnabled = false
local autoScrapItems = {}
local autoScrapperThread = nil
local autoSacrificeEnabled = false
local autoSacrificeThread = nil
local autoStrongholdEnabled = false
local autoStrongholdThread = nil
local strongholdAuraEnabled = false
local candyCount = 0
local diamondCount = 0

local function isTree(model)
    local name = model.Name:lower()
    if autoChopTreeType == "All Trees" then
        return name:find("tree")
    elseif autoChopTreeType == "Small Trees" then
        return name:find("small tree") or name:find("small webbed tree")
    elseif autoChopTreeType == "Big Trees" then
        return name:find("treebig") or name:find("webbedtreebig")
    end
    return false
end

local function createTreeHealthBar(tree)
    if treeHealthBars[tree] then return end
    
    local trunk = tree:FindFirstChild("Trunk") or tree.PrimaryPart
    if not trunk then return end
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "TreeHealthBar"
    billboard.Adornee = trunk
    billboard.Size = UDim2.new(4, 0, 0.4, 0)
    billboard.StudsOffset = Vector3.new(0, 0.5, 0)
    billboard.AlwaysOnTop = true
    billboard.MaxDistance = 200
    billboard.Parent = trunk
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0.3, 0)
    frame.Position = UDim2.new(0, 0, 0.35, 0)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    frame.BorderSizePixel = 0
    frame.Parent = billboard
    
    local fill = Instance.new("Frame")
    fill.Name = "Fill"
    fill.Size = UDim2.new(1, 0, 1, 0)
    fill.BackgroundColor3 = Color3.fromRGB(50, 255, 50)
    fill.BorderSizePixel = 0
    fill.Parent = frame
    
    local corner1 = Instance.new("UICorner")
    corner1.CornerRadius = UDim.new(0, 6)
    corner1.Parent = frame
    
    local corner2 = Instance.new("UICorner")
    corner2.CornerRadius = UDim.new(0, 6)
    corner2.Parent = fill
    
    treeHealthBars[tree] = {
        gui = billboard,
        bar = fill
    }
end

local function updateTreeHealthBar(tree)
    local data = treeHealthBars[tree]
    if not data then return end
    
    local bar = data.bar
    if bar and bar.Parent then
        local health = tree:GetAttribute("Health") or 0
        local name = tree.Name:lower()
        local maxHealth = name:find("big") and 1750 or (name:find("small") and 50 or (name:find("tree") and 500 or 100))
        local healthRatio = math.clamp(health / maxHealth, 0, 1)
        
        bar.Size = UDim2.new(healthRatio, 0, 1, 0)
        
        if healthRatio > 0.6 then
            bar.BackgroundColor3 = Color3.fromRGB(50, 255, 50)
        elseif healthRatio > 0.3 then
            bar.BackgroundColor3 = Color3.fromRGB(255, 200, 0)
        else
            bar.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
        end
        
        if healthRatio <= 0 or health <= 0 then
            if data.gui and data.gui.Parent then
                data.gui:Destroy()
            end
            treeHealthBars[tree] = nil
        end
    end
end

local function removeTreeHealthBar(tree)
    local data = treeHealthBars[tree]
    if data and data.gui and data.gui.Parent then
        data.gui:Destroy()
    end
    treeHealthBars[tree] = nil
end

AutoFeatures:MakeDropdown("Tree Type", {"All Trees", "Small Trees", "Big Trees"}, "All Trees", function(value)
    autoChopTreeType = value
    Window:MakeNotification("Auto Chop", "Tree type set to " .. value, 3)
end)

AutoFeatures:MakeSlider("Auto Chop Range", 10, 100, 75, function(value)
    autoChopRadius = value
    Window:MakeNotification("Auto Chop", "Range set to " .. autoChopRadius, 3)
end)

AutoFeatures:MakeToggle("Auto Chop Trees", false, function(enabled)
    autoChopEnabled = enabled
    if enabled then
        Window:MakeNotification("Auto Chop", "Enabled - radius " .. autoChopRadius .. " studs", 3)
        autoChopThread = task.spawn(function()
            while autoChopEnabled do
                local char = player.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local bestAxe = getBestWeapon()
                    if bestAxe then
                        equipWeapon(bestAxe)
                    end
                    
                    local nearbyParts = Workspace:GetPartBoundsInRadius(hrp.Position, autoChopRadius)
                    local trees = {}
                    
                    for _, part in pairs(nearbyParts) do
                        local tree = part:FindFirstAncestorOfClass("Model")
                        if tree and tree:FindFirstChild("Trunk") and isTree(tree) then
                            trees[tree] = true
                        end
                    end
                    
                    for tree, _ in pairs(trees) do
                        createTreeHealthBar(tree)
                        updateTreeHealthBar(tree)
                    end
                    
                    for tree, data in pairs(treeHealthBars) do
                        if tree.Parent then
                            updateTreeHealthBar(tree)
                        else
                            removeTreeHealthBar(tree)
                        end
                    end
                    
                    for tree, _ in pairs(trees) do
                        if tree.Parent then
                            local targetCFrame
                            local trunk = tree:FindFirstChild("Trunk") or tree.PrimaryPart
                            if trunk then
                                targetCFrame = CFrame.new(trunk.Position + Vector3.new(math.random(-3, 3), math.random(2, 4), math.random(-3, 3)))
                            end
                            
                            if targetCFrame then
                                for i = 1, 3 do
                                    pcall(function()
                                        ReplicatedStorage.RemoteEvents.ToolDamageObject:InvokeServer(tree, bestAxe, "6", targetCFrame)
                                    end)
                                    task.wait(0.05)
                                end
                            end
                        end
                    end
                end
                task.wait(0.25)
            end
            
            for tree, _ in pairs(treeHealthBars) do
                removeTreeHealthBar(tree)
            end
            treeHealthBars = {}
            Window:MakeNotification("Auto Chop", "Stopped.", 3)
        end)
    else
        if autoChopThread then
            task.cancel(autoChopThread)
            autoChopThread = nil
        end
        for tree, _ in pairs(treeHealthBars) do
            removeTreeHealthBar(tree)
        end
        treeHealthBars = {}
        Window:MakeNotification("Auto Chop", "Disabled.", 3)
    end
end)

AutoFeatures:MakeToggle("Auto Revive Teammates", false, function(enabled)
    autoReviveEnabled = enabled
    if enabled then
        Window:MakeNotification("Auto Revive", "Enabled", 3)
        autoReviveThread = task.spawn(function()
            while autoReviveEnabled do
                for _, plr in pairs(game.Players:GetPlayers()) do
                    if plr ~= player and plr.Character then
                        local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
                        if humanoid and humanoid.Health <= 0 then
                            local items = Workspace:FindFirstChild("Items")
                            if items then
                                local reviveItem = nil
                                for _, item in pairs(items:GetChildren()) do
                                    if item.Name == "Medkit" or item.Name == "Bandage" then
                                        if autoReviveItem == "Both" or item.Name == autoReviveItem then
                                            reviveItem = item
                                            break
                                        end
                                    end
                                end
                                if reviveItem then
                                    pcall(function()
                                        ReplicatedStorage.RemoteEvents.RequestRevivePlayer:FireServer(reviveItem)
                                    end)
                                end
                            end
                        end
                    end
                end
                task.wait(0.5)
            end
        end)
    else
        if autoReviveThread then
            task.cancel(autoReviveThread)
            autoReviveThread = nil
        end
        Window:MakeNotification("Auto Revive", "Disabled", 3)
    end
end)

AutoFeatures:MakeDropdown("Revive With", {"Medkit", "Bandage", "Both"}, "Both", function(value)
    autoReviveItem = value
    Window:MakeNotification("Auto Revive", "Selected item: " .. value, 3)
end)

AutoFeatures:MakeToggle("Auto Potions", false, function(enabled)
    autoPotionsEnabled = enabled
    if enabled then
        Window:MakeNotification("Auto Potions", "Enabled", 3)
        autoPotionsThread = task.spawn(function()
            while autoPotionsEnabled do
                local cauldron = Workspace.Map and Workspace.Map.Campground and Workspace.Map.Campground.Cauldron
                if cauldron and cauldron.Functional and cauldron.Functional.Recipe then
                    for _, recipePart in pairs(cauldron.Functional.Recipe:GetChildren()) do
                        local required = recipePart:GetAttribute("Required")
                        if required and not recipePart:GetAttribute("AlreadyDone") then
                            if autoBuySeedsEnabled then
                                local name = recipePart.Name:lower()
                                local plantMap = {
                                    dripleaf = "Dripleaf Plant",
                                    mandrake = "Mandrake Plant",
                                    moonflower = "Moonflower Plant",
                                    stareweed = "Stareweed Plant",
                                    ["cave vine"] = "Cave Vine Plant"
                                }
                                
                                for key, plantName in pairs(plantMap) do
                                    if name:find(key) then
                                        local shops = ReplicatedStorage:FindFirstChild("Shops")
                                        if shops then
                                            local fairyShop = shops:FindFirstChild("Fairy")
                                            if fairyShop then
                                                local plantItem = fairyShop:FindFirstChild(plantName)
                                                if plantItem then
                                                    pcall(function()
                                                        ReplicatedStorage.RemoteEvents.BuyBox:InvokeServer(plantItem)
                                                        Window:MakeNotification("Auto Buy Seeds", "Purchased " .. plantName .. " for recipe.", 3)
                                                    end)
                                                end
                                            end
                                        end
                                        break
                                    end
                                end
                            end
                            
                            local items = Workspace:FindFirstChild("Items")
                            if items then
                                local cauldronPos = cauldron:GetPivot() + Vector3.new(0, 3, 0)
                                local count = 0
                                for _, item in pairs(items:GetChildren()) do
                                    if item.Name:lower():find(recipePart.Name:lower()) then
                                        pcall(function()
                                            ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                                            task.wait(0.1)
                                            item:SetPrimaryPartCFrame(cauldronPos)
                                            count = count + 1
                                            if count >= required then break end
                                        end)
                                    end
                                end
                            end
                        end
                    end
                end
                task.wait(2)
            end
        end)
    else
        if autoPotionsThread then
            task.cancel(autoPotionsThread)
            autoPotionsThread = nil
        end
        Window:MakeNotification("Auto Potions", "Disabled", 3)
    end
end)

AutoFeatures:MakeToggle("Auto Buy Seeds", false, function(enabled)
    autoBuySeedsEnabled = enabled
    Window:MakeNotification("Auto Buy Seeds", enabled and "Enabled" or "Disabled", 3)
end)

AutoFeatures:MakeDropdown("Fuel Type", {"All", "Log", "Fuel Canister", "Oil Barrel", "Coal"}, {"All"}, function(values)
    if table.find(values, "All") then
        autoFuelTypes = {"Log", "Fuel Canister", "Oil Barrel", "Coal"}
    else
        autoFuelTypes = values
    end
    Window:MakeNotification("Auto Fuel Type", "Set to " .. (#autoFuelTypes > 1 and table.concat(autoFuelTypes, ", ") or autoFuelTypes[1]), 3)
end)

AutoFeatures:MakeToggle("Auto Fuel Fire", false, function(enabled)
    autoFuelFireEnabled = enabled
    if enabled then
        Window:MakeNotification("Auto Fuel Fire", "Enabled", 3)
        autoFuelThread = task.spawn(function()
            while autoFuelFireEnabled do
                local items = Workspace:FindFirstChild("Items")
                if items then
                    local firePos = CFrame.new(0, 20, 0)
                    local validItems = {
                        Log = true,
                        ["Fuel Canister"] = true,
                        ["Oil Barrel"] = true,
                        Coal = true
                    }
                    
                    for _, item in pairs(items:GetChildren()) do
                        if item:IsA("Model") and item.PrimaryPart then
                            if validItems[item.Name] and (table.find(autoFuelTypes, "All") or table.find(autoFuelTypes, item.Name)) then
                                pcall(function()
                                    ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                                    task.wait(0.05)
                                    item:SetPrimaryPartCFrame(firePos)
                                end)
                            end
                        end
                    end
                end
                task.wait(1)
            end
        end)
    else
        if autoFuelThread then
            task.cancel(autoFuelThread)
            autoFuelThread = nil
        end
        Window:MakeNotification("Auto Fuel Fire", "Disabled", 3)
    end
end)

AutoFeatures:MakeToggle("Auto Sacrifice Cultists", false, function(enabled)
    autoSacrificeEnabled = enabled
    if enabled then
        Window:MakeNotification("Auto Sacrifice", "Enabled", 3)
        autoSacrificeThread = task.spawn(function()
            while autoSacrificeEnabled do
                local volcano = Workspace.Map and Workspace.Map.Landmarks and Workspace.Map.Landmarks:FindFirstChild("Volcano")
                if volcano and volcano.Functional then
                    local lava = volcano.Functional:FindFirstChild("Lava")
                    if lava and lava:IsA("BasePart") then
                        local items = Workspace:FindFirstChild("Items")
                        if items then
                            for _, item in pairs(items:GetChildren()) do
                                if item:IsA("Model") and (item.Name == "Cultist" or item.Name == "Crossbow Cultist") then
                                    pcall(function()
                                        ReplicatedStorage.RemoteEvents.RequestLavaBurnItem:InvokeServer(item, lava)
                                    end)
                                end
                            end
                        end
                    end
                end
                task.wait(5)
            end
        end)
    else
        if autoSacrificeThread then
            task.cancel(autoSacrificeThread)
            autoSacrificeThread = nil
        end
        Window:MakeNotification("Auto Sacrifice", "Disabled", 3)
    end
end)

local scrapItemList = {
    "Bolt", "Broken Fan", "Broken Microwave", "Broken Radio", "Metal Chair", 
    "Old Car Engine", "Sheet Metal", "Tyre", "Washing Machine", "Log", 
    "Chair", "Cultist Gem", "Forest Gem Fragment", "Forest Gem", "UFO Scrap", 
    "Cultist Prototype", "Cultist Experiment", "UFO Component", "UFO Junk"
}
table.sort(scrapItemList, function(a, b) return a:lower() < b:lower() end)
table.insert(scrapItemList, 1, "Deselect All")
table.insert(scrapItemList, 1, "All")

AutoFeatures:MakeDropdown("Scrap Items", scrapItemList, {}, function(values)
    if table.find(values, "All") then
        local allItems = {}
        for _, item in ipairs(scrapItemList) do
            if item ~= "All" and item ~= "Deselect All" then
                table.insert(allItems, item)
            end
        end
        autoScrapItems = allItems
        Window:MakeNotification("Scrap Items", "All items selected", 3)
    elseif table.find(values, "Deselect All") then
        autoScrapItems = {}
        Window:MakeNotification("Scrap Items", "All items deselected", 3)
    else
        autoScrapItems = values
    end
end)

AutoFeatures:MakeToggle("Auto Scrapper", false, function(enabled)
    autoScrapperEnabled = enabled
    if enabled then
        Window:MakeNotification("Auto Scrapper", "Enabled", 3)
        autoScrapperThread = task.spawn(function()
            while autoScrapperEnabled do
                local items = Workspace:FindFirstChild("Items")
                if items then
                    local scrapperPos = CFrame.new(21, 17, -5)
                    for _, item in pairs(items:GetChildren()) do
                        if item:IsA("Model") and item.PrimaryPart and table.find(autoScrapItems, item.Name) then
                            pcall(function()
                                ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                                task.wait(0.05)
                                item:SetPrimaryPartCFrame(scrapperPos)
                            end)
                        end
                    end
                end
                task.wait(2)
            end
        end)
    else
        if autoScrapperThread then
            task.cancel(autoScrapperThread)
            autoScrapperThread = nil
        end
        Window:MakeNotification("Auto Scrapper", "Disabled", 3)
    end
end)

local function updateStatsDisplay()
    candyCount = player:GetAttribute("Candy") or 0
    diamondCount = player:GetAttribute("Diamonds") or 0
end

player:GetAttributeChangedSignal("Candy"):Connect(updateStatsDisplay)
player:GetAttributeChangedSignal("Diamonds"):Connect(updateStatsDisplay)
updateStatsDisplay()

AutoFeatures:MakeToggle("Auto Stronghold", false, function(enabled)
    autoStrongholdEnabled = enabled
    if enabled then
        Window:MakeNotification("Auto Stronghold", "Starting...", 3)
        pcall(function()
            ReplicatedStorage.RemoteEvents.RequestOpenItemChest:Wait()
        end)
        
        autoStrongholdThread = task.spawn(function()
            while autoStrongholdEnabled do
                local stronghold = Workspace.Map and Workspace.Map.Landmarks and Workspace.Map.Landmarks:FindFirstChild("Stronghold")
                if stronghold and stronghold.Functional then
                    local sign = stronghold.Functional:FindFirstChild("Sign")
                    if sign and sign:FindFirstChild("SurfaceGui") then
                        Window:MakeNotification("Auto Stronghold", "Waiting for Stronghold ready...", 3)
                        
                        local triggerZone = stronghold.Functional.EnemyWaves12 and stronghold.Functional.EnemyWaves12.Wave1 and stronghold.Functional.EnemyWaves12.Wave1.TriggerZone
                        if triggerZone then
                            local hrp = getHRP()
                            if hrp then
                                hrp.CFrame = triggerZone.CFrame + Vector3.new(0, 4, 0)
                            end
                        end
                        
                        strongholdAuraEnabled = true
                        task.spawn(function()
                            while strongholdAuraEnabled and autoStrongholdEnabled do
                                local char = player.Character
                                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                                local bestWeapon = getBestWeapon()
                                
                                if hrp and bestWeapon then
                                    local characters = Workspace:FindFirstChild("Characters")
                                    if characters then
                                        for _, enemy in pairs(characters:GetChildren()) do
                                            if enemy ~= char then
                                                local enemyHumanoid = enemy:FindFirstChildOfClass("Humanoid")
                                                local enemyHRP = enemy:FindFirstChild("HumanoidRootPart")
                                                if enemyHumanoid and enemyHRP and enemyHumanoid.Health > 0 then
                                                    local distance = (enemyHRP.Position - hrp.Position).Magnitude
                                                    if distance <= 200 then
                                                        pcall(function()
                                                            ReplicatedStorage.RemoteEvents.ToolDamageObject:InvokeServer(enemy, bestWeapon, "Coin_Stack", enemyHRP.CFrame)
                                                        end)
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                                RunService.Heartbeat:Wait()
                            end
                        end)
                        
                        repeat
                            task.wait(1)
                            local items = Workspace:FindFirstChild("Items")
                            local chest = items and items:FindFirstChild("Stronghold Diamond Chest")
                        until (chest and not chest:GetAttribute("Locked")) or not autoStrongholdEnabled
                        
                        strongholdAuraEnabled = false
                        
                        if autoStrongholdEnabled then
                            local items = Workspace:FindFirstChild("Items")
                            local chest = items and items:FindFirstChild("Stronghold Diamond Chest")
                            if chest then
                                pcall(function()
                                    ReplicatedStorage.RemoteEvents.RequestOpenItemChest:FireServer(chest)
                                end)
                            end
                            
                            Window:MakeNotification("Auto Stronghold", "Cycle complete - waiting for next respawn.", 3)
                            task.wait(5)
                        end
                    end
                end
                task.wait(5)
            end
        end)
    else
        autoStrongholdEnabled = false
        strongholdAuraEnabled = false
        if autoStrongholdThread then
            task.cancel(autoStrongholdThread)
            autoStrongholdThread = nil
        end
        Window:MakeNotification("Auto Stronghold", "Disabled", 3)
    end
end)

local BringAllSection = Window:MakeSection("Bring All Features")

BringAllSection:MakeButton("Bring All Kids", function()
    Window:MakeNotification("Starting Kid Collection", "Searching for Lost Children...", 3)
    task.spawn(function()
        local requestBagStoreItem = ReplicatedStorage.RemoteEvents:FindFirstChild("RequestBagStoreItem")
        if requestBagStoreItem then
            local inventory = player:FindFirstChild("Inventory")
            local characters = Workspace:FindFirstChild("Characters")
            local sack = inventory and (inventory:FindFirstChild("Old Sack") or inventory:FindFirstChild("Good Sack") or 
                     inventory:FindFirstChild("Infernal Sack") or inventory:FindFirstChild("Giant Sack"))
            
            if sack then
                local hrp = getHRP()
                if hrp then
                    for _, childName in ipairs({"Lost Child", "Lost Child2", "Lost Child3", "Lost Child4"}) do
                        local child = characters and characters:FindFirstChild(childName)
                        if child and child:FindFirstChild("HumanoidRootPart") then
                            hrp.CFrame = child.HumanoidRootPart.CFrame * CFrame.new(0, 5, 0)
                            task.wait(0.3)
                            pcall(function()
                                requestBagStoreItem:InvokeServer(sack, child)
                            end)
                            task.wait(0.3)
                        end
                    end
                    
                    hrp.CFrame = CFrame.new(0, 20, 0)
                    Window:MakeNotification("Kid Collection Complete", "Returned to Fire.", 3)
                end
            else
                Window:MakeNotification("No Sack Found", "Need any Sack to collect kids.", 3)
            end
        else
            Window:MakeNotification("Error", "Remote missing.", 3)
        end
    end)
end)

local CraftingSection = Window:MakeSection("Crafting")

local function craftItem(itemName)
    pcall(function()
        ReplicatedStorage.RemoteEvents.CraftItem:InvokeServer(itemName)
        Window:MakeNotification("Crafting", itemName .. " crafted successfully!", 3)
    end)
end

CraftingSection:MakeButton("Map", function() craftItem("Map") end)
CraftingSection:MakeButton("Old Bed", function() craftItem("Old Bed") end)
CraftingSection:MakeButton("Crafting Bench 2", function() craftItem("Crafting Bench 2") end)
CraftingSection:MakeButton("Regular Bed", function() craftItem("Regular Bed") end)
CraftingSection:MakeButton("Crafting Bench 3", function() craftItem("Crafting Bench 3") end)
CraftingSection:MakeButton("Good Bed", function() craftItem("Good Bed") end)
CraftingSection:MakeButton("Crafting Bench 4", function() craftItem("Crafting Bench 4") end)
CraftingSection:MakeButton("Giant Bed", function() craftItem("Giant Bed") end)
CraftingSection:MakeButton("Bear Trap", function() craftItem("Bear trap") end)

local SaplingPlanterSection = Window:MakeSection("Sapling Planter")
local saplingShape = "Circle"
local saplingSpacing = 3
local saplingRadius = 50
local saplingCenter = "Fire"
local previewParts = {}
local previewActive = false
local previewConnection = nil

local function getCenterPosition()
    if saplingCenter == "Player" then
        local hrp = getHRP()
        return hrp and hrp.Position
    else
        local map = Workspace:FindFirstChild("Map")
        local campground = map and map:FindFirstChild("Campground")
        local mainFire = campground and campground:FindFirstChild("MainFire")
        return mainFire and mainFire.PrimaryPart and mainFire.PrimaryPart.Position
    end
end

local function getGroundPosition(position)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("Ground")}
    raycastParams.FilterType = Enum.RaycastFilterType.Include
    raycastParams.IgnoreWater = true
    
    local raycastResult = Workspace:Raycast(position + Vector3.new(0, 50, 0), Vector3.new(0, -200, 0), raycastParams)
    return raycastResult and raycastResult.Position or position
end

local function findSapling()
    local items = Workspace:FindFirstChild("Items")
    if items then
        for _, item in pairs(items:GetChildren()) do
            if item:IsA("Model") and item.Name:lower():find("sapling") then
                return item
            end
        end
    end
    return nil
end

local function plantSapling(position)
    local groundPos = getGroundPosition(position)
    local sapling = findSapling()
    if sapling then
        pcall(function()
            ReplicatedStorage.RemoteEvents.RequestPlantItem:InvokeServer(sapling, groundPos)
        end)
    end
end

local function calculateCirclePoints(center, radius, spacing)
    local circumference = 2 * math.pi * radius
    local pointCount = math.max(3, math.floor(circumference / spacing))
    local points = {}
    
    for i = 1, pointCount do
        local angle = i / pointCount * 2 * math.pi
        local x = center.X + math.cos(angle) * radius
        local z = center.Z + math.sin(angle) * radius
        table.insert(points, Vector3.new(x, center.Y, z))
    end
    
    return points
end

local function calculateSquarePoints(center, radius, spacing)
    local halfSize = radius / 2
    local points = {}
    
    for x = -halfSize, halfSize, spacing do
        for z = -halfSize, halfSize, spacing do
            if math.abs(x) == halfSize or math.abs(z) == halfSize then
                table.insert(points, Vector3.new(center.X + x, center.Y, center.Z + z))
            end
        end
    end
    
    return points
end

local function calculateTrianglePoints(center, radius, spacing)
    local halfSize = radius / 2
    local sqrt3 = math.sqrt(3)
    local height = sqrt3 * halfSize
    
    local point1 = Vector3.new(center.X, center.Y, center.Z - height / 2)
    local point2 = Vector3.new(center.X - halfSize, center.Y, center.Z + height / 2)
    local point3 = Vector3.new(center.X + halfSize, center.Y, center.Z + height / 2)
    
    local points = {}
    
    local function interpolatePoints(p1, p2)
        local dir = p2 - p1
        local length = dir.Magnitude
        local unit = dir.Unit
        
        for dist = 0, length, spacing do
            table.insert(points, p1 + unit * dist)
        end
    end
    
    interpolatePoints(point1, point2)
    interpolatePoints(point2, point3)
    interpolatePoints(point3, point1)
    
    return points
end

local function getSaplingPoints()
    local center = getCenterPosition()
    if not center then return {} end
    
    if saplingShape == "Circle" then
        return calculateCirclePoints(center, saplingRadius, saplingSpacing)
    elseif saplingShape == "Square" then
        return calculateSquarePoints(center, saplingRadius, saplingSpacing)
    elseif saplingShape == "Triangle" then
        return calculateTrianglePoints(center, saplingRadius, saplingSpacing)
    end
    
    return {}
end

local function clearPreview()
    for _, part in pairs(previewParts) do
        if part and part.Parent then
            part:Destroy()
        end
    end
    previewParts = {}
    
    if previewConnection then
        previewConnection:Disconnect()
        previewConnection = nil
    end
    
    previewActive = false
end

local function createPreview()
    clearPreview()
    
    local center = getCenterPosition()
    if not center then return end
    
    local points = getSaplingPoints()
    if #points == 0 then return end
    
    previewActive = true
    
    for _, point in ipairs(points) do
        local part = Instance.new("Part")
        part.Anchored = true
        part.CanCollide = false
        part.CanTouch = false
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(0, 255, 0)
        part.Size = Vector3.new(1, 0.2, 1)
        part.CFrame = CFrame.new(point + Vector3.new(0, 2, 0))
        part.Transparency = 0.25
        part.Name = "AxomPreview"
        part.Parent = Workspace
        
        table.insert(previewParts, part)
    end
    
    if saplingCenter == "Player" then
        previewConnection = RunService.RenderStepped:Connect(function()
            if previewActive then
                local hrp = getHRP()
                if hrp then
                    local newPoints = getSaplingPoints()
                    for i, point in ipairs(newPoints) do
                        if previewParts[i] then
                            previewParts[i].CFrame = CFrame.new(point + Vector3.new(0, 2, 0))
                        end
                    end
                end
            else
                if previewConnection then
                    previewConnection:Disconnect()
                    previewConnection = nil
                end
            end
        end)
    end
end

SaplingPlanterSection:MakeDropdown("Center Position", {"Fire", "Player"}, "Fire", function(value)
    saplingCenter = value
    if previewActive then
        createPreview()
    end
end)

SaplingPlanterSection:MakeDropdown("Shape", {"Circle", "Square", "Triangle"}, "Circle", function(value)
    saplingShape = value
    if previewActive then
        createPreview()
    end
end)

SaplingPlanterSection:MakeSlider("Spacing (studs)", 1, 5, 3, 0.5, function(value)
    saplingSpacing = value
    if previewActive then
        createPreview()
    end
end)

SaplingPlanterSection:MakeSlider("Size / Radius (studs)", 35, 185, 50, 5, function(value)
    saplingRadius = value
    if previewActive then
        createPreview()
    end
end)

SaplingPlanterSection:MakeButton("Plant Saplings", function()
    if previewActive and #previewParts > 0 then
        local center = getCenterPosition()
        if center then
            local points = getSaplingPoints()
            for _, point in ipairs(points) do
                task.spawn(function()
                    plantSapling(point)
                    RunService.Heartbeat:Wait()
                end)
            end
            clearPreview()
            Window:MakeNotification("Planting", string.format("Planted %s | Radius: %d | Spacing: %.1f | Center: %s", saplingShape, saplingRadius, saplingSpacing, saplingCenter), 3)
        end
    else
        createPreview()
        Window:MakeNotification("Preview Active", "Visualizer created. Adjust sliders or click again to confirm/cancel.", 3)
    end
end)

local TeleportSection = Window:MakeSection("Teleport Locations")

local teleportFunctions = {
    Fire = function()
        return CFrame.new(0, 15, 0)
    end,
    Stronghold = function()
        local stronghold = Workspace.Map and Workspace.Map.Landmarks and Workspace.Map.Landmarks:FindFirstChild("Stronghold")
        if stronghold and stronghold.Functional then
            local sign = stronghold.Functional:FindFirstChild("Sign")
            if sign then
                return sign.CFrame * CFrame.new(0, 0, 5)
            end
        end
    end,
    Anvil = function()
        local toolWorkshop = Workspace.Map and Workspace.Map.Landmarks and Workspace.Map.Landmarks:FindFirstChild("ToolWorkshop")
        if toolWorkshop and toolWorkshop.Functional then
            local anvilHologram = toolWorkshop.Functional:FindFirstChild("AnvilHologram")
            if anvilHologram and anvilHologram:FindFirstChild("HumanoidRootPart") then
                return anvilHologram.HumanoidRootPart.CFrame
            end
        end
    end,
    Upgrade = function()
        local skillsBuilding = Workspace.Map and Workspace.Map.Landmarks and Workspace.Map.Landmarks:FindFirstChild("SkillsBuilding")
        if skillsBuilding and skillsBuilding.Functional then
            local rodBench = skillsBuilding.Functional:FindFirstChild("RodBench")
            if rodBench and rodBench:FindFirstChild("PromptPart") then
                return rodBench.PromptPart.CFrame * CFrame.new(-10, 0, 0)
            end
        end
    end,
    ["Fairy House"] = function()
        local fairyHouse = Workspace.Map and Workspace.Map.Landmarks and Workspace.Map.Landmarks:FindFirstChild("Fairy House")
        if fairyHouse and fairyHouse.Functional then
            local playerPart = fairyHouse.Functional:FindFirstChild("PlayerPart")
            if playerPart then
                return playerPart.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end,
    ["Ice Temple"] = function()
        local iceTemple = Workspace.Map and Workspace.Map.Landmarks and Workspace.Map.Landmarks:FindFirstChild("Ice Temple")
        if iceTemple then
            local main = iceTemple:FindFirstChild("Main")
            if main then
                return main.CFrame + Vector3.new(0, 3, 0)
            end
        end
    end,
    Volcano = function()
        local volcano = Workspace.Map and Workspace.Map.Landmarks and Workspace.Map.Landmarks:FindFirstChild("Volcano")
        if volcano and volcano.Functional and volcano.Functional:FindFirstChild("Sacrifice") then
            local altar = volcano.Functional.Sacrifice:FindFirstChild("Altar")
            if altar and altar:FindFirstChild("Platform") then
                local platform = altar.Platform
                if platform:IsA("BasePart") then
                    return platform.CFrame + Vector3.new(0, 5, 0)
                end
            end
        end
    end,
    Carnival = function()
        local map = Workspace:FindFirstChild("Map")
        if map then
            local landmarks = map:FindFirstChild("Landmarks")
            if landmarks then
                local halloweenCarnival = landmarks:FindFirstChild("Halloween Carnival")
                if halloweenCarnival and halloweenCarnival:FindFirstChild("Main") then
                    local main = halloweenCarnival.Main
                    if main:IsA("BasePart") then
                        return main.CFrame + Vector3.new(0, 5, 0)
                    end
                end
            end
        end
    end,
    ["Furniture Trader"] = function()
        local characters = Workspace:FindFirstChild("Characters")
        if characters then
            local furnitureTrader = characters:FindFirstChild("Furniture Trader")
            if furnitureTrader and furnitureTrader:FindFirstChild("HumanoidRootPart") then
                return furnitureTrader.HumanoidRootPart.CFrame
            end
        end
    end
}

local teleportLocations = {}
for locationName, _ in pairs(teleportFunctions) do
    table.insert(teleportLocations, locationName)
end
table.sort(teleportLocations)

local selectedTeleport = "Fire"

TeleportSection:MakeDropdown("Select Location", teleportLocations, "Fire", function(location)
    selectedTeleport = location
end)

TeleportSection:MakeButton("Teleport", function()
    local teleportFunc = teleportFunctions[selectedTeleport]
    if teleportFunc then
        local cframe = teleportFunc()
        if cframe then
            local hrp = getHRP()
            if hrp then
                hrp.CFrame = cframe
                Workspace.CurrentCamera.CFrame = cframe
                Window:MakeNotification("Teleported!", "You are now at " .. selectedTeleport, 3)
            end
        else
            Window:MakeNotification(selectedTeleport .. " Not Found", "Target part missing or invalid.", 3)
        end
    else
        Window:MakeNotification("Invalid Selection", "No teleport function found for: " .. tostring(selectedTeleport), 3)
    end
end)

local PlayerTeleportSection = Window:MakeSection("Teleport to Player")

local function getPlayerList()
    local players = {}
    for _, plr in pairs(game.Players:GetPlayers()) do
        if plr ~= player then
            table.insert(players, plr.Name)
        end
    end
    table.sort(players)
    return players
end

local selectedPlayer = nil

PlayerTeleportSection:MakeDropdown("Select Player", getPlayerList(), nil, function(playerName)
    selectedPlayer = playerName
end)

PlayerTeleportSection:MakeButton("Teleport to Player", function()
    if selectedPlayer then
        local targetPlayer = game.Players:FindFirstChild(selectedPlayer)
        if targetPlayer and targetPlayer.Character then
            local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetHRP then
                local hrp = getHRP()
                if hrp then
                    hrp.CFrame = targetHRP.CFrame * CFrame.new(0, 0, 3)
                    Window:MakeNotification("Teleported!", "You are now near " .. selectedPlayer, 3)
                end
            else
                Window:MakeNotification("Teleport Failed", "Target player missing HumanoidRootPart.", 3)
            end
        else
            Window:MakeNotification("Teleport Failed", "Player not found or character missing.", 3)
        end
    else
        Window:MakeNotification("Teleport Failed", "No player selected.", 3)
    end
end)

game.Players.PlayerAdded:Connect(function()
    PlayerTeleportSection:UpdateDropdown("Select Player", getPlayerList())
end)

game.Players.PlayerRemoving:Connect(function()
    PlayerTeleportSection:UpdateDropdown("Select Player", getPlayerList())
end)

local BringStuffSection = Window:MakeSection("Bring Stuff")
local bringLocation = "Player"
local bringLocations = {
    Player = function()
        local hrp = getHRP()
        return hrp and hrp.CFrame * CFrame.new(0, 0, -3)
    end,
    Scrapper = CFrame.new(21, 17, -5),
    Fire = CFrame.new(0, 20, 0)
}

local function bringItems(itemNames)
    local items = Workspace:FindFirstChild("Items")
    if not items then
        Window:MakeNotification("Error", "workspace.Items not found", 3)
        return
    end
    
    local targetCFrame = bringLocations[bringLocation]
    if not targetCFrame then
        if type(bringLocations[bringLocation]) == "function" then
            targetCFrame = bringLocations[bringLocation]()
        end
    end
    
    if not targetCFrame then
        Window:MakeNotification("Error", "No valid teleport destination", 3)
        return
    end
    
    local itemCount = 0
    local itemStats = {}
    
    for _, item in pairs(items:GetChildren()) do
        if item:IsA("Model") and item.PrimaryPart then
            if itemNames[item.Name] then
                task.spawn(function()
                    for _, weld in pairs(item:GetDescendants()) do
                        if weld:IsA("Weld") or weld:IsA("Motor6D") then
                            weld:Destroy()
                        elseif weld:IsA("BasePart") then
                            weld.Anchored = false
                        end
                    end
                    
                    local originalCFrame = item.PrimaryPart.CFrame
                    item:SetPrimaryPartCFrame(originalCFrame + Vector3.new(0.01, 0, 0))
                    task.wait(0.02)
                    item:SetPrimaryPartCFrame(originalCFrame)
                    task.wait(0.05)
                    
                    pcall(function()
                        ReplicatedStorage.RemoteEvents.RequestStartDraggingItem:FireServer(item)
                    end)
                    task.wait(0.1)
                    
                    local offset = Vector3.new(0, 8, 0)
                    item:SetPrimaryPartCFrame(targetCFrame + offset)
                    task.wait(0.1)
                    
                    pcall(function()
                        ReplicatedStorage.RemoteEvents.StopDraggingItem:FireServer(item)
                    end)
                    
                    itemStats[item.Name] = (itemStats[item.Name] or 0) + 1
                    itemCount = itemCount + 1
                end)
            end
        end
    end
    
    task.delay(0.8, function()
        local itemList = {}
        for itemName, count in pairs(itemStats) do
            local plural = count ~= 1 and "s" or ""
            table.insert(itemList, string.format("%d %s%s", count, itemName, plural))
        end
        
        local summary = #itemList > 0 and table.concat(itemList, ", ") or "No matching items."
        Window:MakeNotification(string.format("Brought %d item%s", itemCount, itemCount ~= 1 and "s" or ""), summary, 3)
    end)
end

local function createBringCategory(categoryName, items)
    local sortedItems = {}
    for _, item in ipairs(items) do
        table.insert(sortedItems, item)
    end
    table.sort(sortedItems, function(a, b) return string.lower(a) < string.lower(b) end)
    table.insert(sortedItems, 1, "Deselect All")
    table.insert(sortedItems, 1, "All")
    
    local selectedItems = {}
    local dropdownRef = nil
    
    BringStuffSection:MakeDropdown("Select " .. categoryName, sortedItems, {}, function(values)
        if table.find(values, "All") then
            selectedItems = {}
            for _, item in ipairs(sortedItems) do
                if item ~= "All" and item ~= "Deselect All" then
                    table.insert(selectedItems, item)
                end
            end
            Window:MakeNotification("Selected All", categoryName .. " items selected.", 3)
        elseif table.find(values, "Deselect All") then
            selectedItems = {}
            Window:MakeNotification("Deselected All", categoryName .. " cleared.", 3)
        else
            selectedItems = values
        end
    end)
    
    BringStuffSection:MakeButton("Bring " .. categoryName, function()
        if #selectedItems > 0 then
            local itemMap = {}
            for _, itemName in ipairs(selectedItems) do
                itemMap[itemName] = true
            end
            bringItems(itemMap)
        else
            Window:MakeNotification("Nothing Selected", "Pick items first.", 3)
        end
    end)
end

BringStuffSection:MakeDropdown("Teleport Target", {"Player", "Scrapper", "Fire"}, "Player", function(value)
    bringLocation = value
end)

createBringCategory("Heals / Food", {
    "Bandage", "Cake", "Carrot", "Corn", "MedKit", "Pumpkin", "Stew", "Mackerel", 
    "Cooked Mackerel", "Salmon", "Cooked Salmon", "Steak", "Cooked Steak", 
    "Steak Dinner", "Chili", "Carrot Cake", "Meat? Sandwich", "Apple", 
    "Morsel", "Cooked Morsel"
})

createBringCategory("Fuel", {
    "Coal", "Fuel Canister", "Log", "Oil Barrel", "Sapling", "Cultist", "Crossbow Cultist"
})

createBringCategory("Metal / Scrap", {
    "Bolt", "Broken Fan", "Broken Microwave", "Old Radio", "Metal Chair", 
    "Old Car Engine", "Sheet Metal", "Tyre", "Washing Machine", "Cultist Gem", 
    "UFO Junk", "UFO Component", "Cultist Experiment", "Cultist Prototype", 
    "UFO Scrap", "Forest Gem", "Forest Gem Fragment"
})

createBringCategory("Tools / Gear", {
    "Alien Armour", "Armour Trim Kit", "Axe Trim Kit", "Chainsaw", "Frog Boots", 
    "Giant Sack", "Good Axe", "Good Sack", "Infernal Crossbow", "Infernal Sack", 
    "Infernal Sword", "Ice Axe", "Ice Sword", "Laser Cannon", "Leather Body", 
    "Iron Body", "Mammoth Helmet", "Morningstar", "Obsidiron Body", 
    "Obsidiron Boots", "Old Axe", "Poison Armour", "Raygun", "Revolver", 
    "Revolver Ammo", "Rifle", "Rifle Ammo", "Spear", "Strong Axe", 
    "Tactical Shotgun", "Thorn Body"
})

createBringCategory("Other", {
    "Alpha Wolf Pelt", "Bear Corpse", "Bear Pelt", "Bunny Foot", "Candy", 
    "Defense Blueprint", "Diamond", "Feather", "Flower", "Frog Key", 
    "Gem of the Forest Fragment", "Gold Shard", "Halloween Candle", 
    "Mammoth Tusk", "Meteor Shard", "Old Flashlight", "Old Rod", 
    "Raw Obsidiron Ore", "Sacrifice Totem", "Seed Box", "Strong Flashlight", 
    "Wildfire", "Wolf Pelt"
})

BringStuffSection:MakeButton("Bring All Items", function()
    local items = Workspace:FindFirstChild("Items")
    if items then
        local allItems = {}
        for _, item in pairs(items:GetChildren()) do
            if item:IsA("Model") then
                allItems[item.Name] = true
            end
        end
        bringItems(allItems)
        Window:MakeNotification("Bring All", "Bringing all available items (CAN CAUSE LAG)", 3)
    else
        Window:MakeNotification("Error", "workspace.Items not found.", 3)
    end
end)

local MiscSection = Window:MakeSection("Miscellaneous")
local instantInteractEnabled = false
local instantInteractConnections = {}
local instantInteractData = {}
local autoOpenChestsEnabled = false
local autoOpenChestsThread = nil

local fishing100Enabled = false
local flute100Enabled = false
local destroyItemsList = {}
local destroyItemsDropdown = nil

local function enableFishing100()
    task.spawn(function()
        repeat task.wait() until player:FindFirstChild("PlayerScripts") and 
              ReplicatedStorage:FindFirstChild("Tools") and 
              ReplicatedStorage.Tools:FindFirstChild("Fishing Rod")
        
        local fishingRod = require(ReplicatedStorage.Tools["Fishing Rod"])
        local client = require(player.PlayerScripts:WaitForChild("Client"))
        
        local originalPull = fishingRod.Pull
        fishingRod.Pull = function(self)
            self.CatchProgress = self.CatchProgress + 1
            client.Sound.Play("FishHitMarker")
            
            if self.CatchProgress < self.CatchGoal then
                if self.CatchProgress > 0 then
                    self.LastPullTime = time()
                    client.Events.PlayAnimation:Fire("Rod_Reel", {Speed = 2})
                    
                    if client.FirstPersonModule and client.FirstPersonModule.PlayAnimation then
                        client.FirstPersonModule.PlayAnimation("Rod_Reel", nil, 4, 2)
                    end
                else
                    self.ItemCaught = nil
                    self:Reel()
                end
            else
                self.ItemCaught = true
                client.Events.ConfirmCatchItem:FireServer()
                
                local soundParams = {
                    Volume = 0.5,
                    Replicate = true,
                    ReplicationProperties = {
                        Instance = player.Character and player.Character:FindFirstChild("Head"),
                        Volume = 0.4
                    }
                }
                client.Sound.Play("FishCatch", soundParams)
                self:Reel()
            end
        end
    end)
end

local function enableFlute100()
    task.spawn(function()
        repeat task.wait() until ReplicatedStorage:FindFirstChild("Tools") and 
              ReplicatedStorage.Tools:FindFirstChild("Taming Flute")
        
        local tamingFlute = require(ReplicatedStorage.Tools["Taming Flute"])
        local client = require(player.PlayerScripts:WaitForChild("Client"))
        
        local originalStart = tamingFlute.StartTamingMinigame
        tamingFlute.StartTamingMinigame = function(self, target, realModel)
            originalStart(self, target, realModel)
            RunService:UnbindFromRenderStep("TamingFluteMinigame")
            RunService:BindToRenderStep("TamingFluteMinigame", Enum.RenderPriority.First.Value, function()
                if self.TamingMinigameActive then
                    local maxTime = 3
                    local delta = RunService.RenderStepped:Wait()
                    self.TamingTime = math.clamp(self.TamingTime + 5 * delta, 0, maxTime)
                    
                    if self.TamingTime >= maxTime then
                        self:StopTamingMinigame()
                        
                        if client.Sound then
                            local soundParams = {
                                Volume = 0.45,
                                Replicate = true,
                                ReplicationProperties = {
                                    Instance = player.Character and player.Character:FindFirstChild("Head"),
                                    Volume = 0.35
                                }
                            }
                            client.Sound.Play("FluteAlert", soundParams)
                        end
                        
                        if client.Events and client.Events.RequestTame_Hungry then
                            client.Events.RequestTame_Hungry:FireServer(target, self.RealModel)
                        end
                    end
                end
            end)
        end
    end)
end

local function getDestroyableItems()
    local items = Workspace:FindFirstChild("Items")
    if not items then return {} end
    
    local itemList = {}
    local seen = {}
    
    for _, item in pairs(items:GetChildren()) do
        if item:IsA("Model") and item.PrimaryPart and not item.PrimaryPart.Anchored then
            if not seen[item.Name] then
                seen[item.Name] = true
                table.insert(itemList, item.Name)
            end
        end
    end
    
    table.sort(itemList, function(a, b) return string.lower(a) < string.lower(b) end)
    table.insert(itemList, 1, "Deselect All")
    table.insert(itemList, 1, "All")
    
    return itemList
end

local function destroySelectedItems()
    if #destroyItemsList == 0 then
        Window:MakeNotification("Nothing Selected", "Pick items first.", 3)
        return
    end
    
    local items = Workspace:FindFirstChild("Items")
    if not items then
        Window:MakeNotification("Error", "workspace.Items not found.", 3)
        return
    end
    
    local destroyCount = 0
    local voidPos = CFrame.new(20.9845886, -750, 2.40254974)
    
    for _, item in pairs(items:GetChildren()) do
        if table.find(destroyItemsList, item.Name) and item:IsA("Model") and item.PrimaryPart and not item.PrimaryPart.Anchored then
            task.spawn(function()
                item.PrimaryPart.Anchored = false
                
                for _, weld in pairs(item:GetDescendants()) do
                    if weld:IsA("Weld") or weld:IsA("Motor6D") then
                        weld:Destroy()
                    end
                end
                
                pcall(function()
                    ReplicatedStorage.RemoteEvents.DragItem:FireServer(item)
                end)
                task.wait(0.03)
                item:SetPrimaryPartCFrame(voidPos)
                task.wait(0.03)
                pcall(function()
                    ReplicatedStorage.RemoteEvents.StopDraggingItem:FireServer(item)
                end)
                
                destroyCount = destroyCount + 1
            end)
        end
    end
    
    task.delay(0.5, function()
        Window:MakeNotification("Destroyed Items", "Teleported " .. destroyCount .. " item(s) to the void.", 3)
    end)
end

MiscSection:MakeToggle("Instant Interact", false, function(enabled)
    instantInteractEnabled = enabled
    if enabled then
        for _, prompt in pairs(Workspace:GetDescendants()) do
            if prompt:IsA("ProximityPrompt") then
                if instantInteractData[prompt] == nil then
                    instantInteractData[prompt] = prompt.HoldDuration
                end
                prompt.HoldDuration = 0
            end
        end
        
        table.insert(instantInteractConnections, Workspace.DescendantAdded:Connect(function(descendant)
            if instantInteractEnabled and descendant:IsA("ProximityPrompt") then
                if instantInteractData[descendant] == nil then
                    instantInteractData[descendant] = descendant.HoldDuration
                end
                descendant.HoldDuration = 0
            end
        end))
        
        table.insert(instantInteractConnections, ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
            if instantInteractEnabled and prompt:IsA("ProximityPrompt") then
                prompt.HoldDuration = 0
            end
        end))
        
        Window:MakeNotification("Instant Interact", "Hold time is now zero", 3)
    else
        for prompt, duration in pairs(instantInteractData) do
            if prompt and prompt.Parent then
                prompt.HoldDuration = duration
            end
        end
        
        for _, connection in pairs(instantInteractConnections) do
            connection:Disconnect()
        end
        instantInteractConnections = {}
        instantInteractData = {}
        
        Window:MakeNotification("Instant Interact", "Hold times restored", 3)
    end
end)

MiscSection:MakeToggle("100% Fishing", false, function(enabled)
    fishing100Enabled = enabled
    if enabled then
        enableFishing100()
        Window:MakeNotification("Fishing Enabled", "Instant catch active.", 3)
    else
        Window:MakeNotification("Fishing Disabled", "Rejoin to restore normal.", 3)
    end
end)

MiscSection:MakeToggle("100% Flute", false, function(enabled)
    flute100Enabled = enabled
    if enabled then
        enableFlute100()
        Window:MakeNotification("Flute Enabled", "100% Flute active.", 3)
    else
        Window:MakeNotification("Flute Disabled", "Rejoin to restore normal.", 3)
    end
end)

local destroyItems = getDestroyableItems()
MiscSection:MakeDropdown("Select Items to Destroy", destroyItems, {}, function(values)
    if table.find(values, "All") then
        destroyItemsList = {}
        for _, item in ipairs(destroyItems) do
            if item ~= "All" and item ~= "Deselect All" then
                table.insert(destroyItemsList, item)
            end
        end
        Window:MakeNotification("Selected All", "All unanchored items selected.", 3)
    elseif table.find(values, "Deselect All") then
        destroyItemsList = {}
        Window:MakeNotification("Deselected All", "Cleared selection.", 3)
    else
        destroyItemsList = values
    end
end)

MiscSection:MakeButton("Destroy Selected", function()
    destroySelectedItems()
end)

MiscSection:MakeButton("Update Destroy List", function()
    local newItems = getDestroyableItems()
    Window:MakeNotification("Destroy Items", "List updated (" .. tostring(#newItems - 2) .. " unanchored types found).", 3)
end)

local function revealMap()
    if _G.RevealMapRunning then return end
    _G.RevealMapRunning = true
    
    Window:MakeNotification("Reveal Map", "Starting reveal and auto-fuel...", 3)
    
    task.spawn(function()
        local function getCharacter()
            return player.Character or player.CharacterAdded:Wait()
        end
        
        local function getCampfire()
            local map = Workspace:FindFirstChild("Map")
            local campground = map and map:FindFirstChild("Campground")
            return campground and campground:FindFirstChild("MainFire")
        end
        
        task.spawn(function()
            while _G.RevealMapRunning do
                task.wait(0.15)
                local campfire = getCampfire()
                local items = Workspace:FindFirstChild("Items")
                local requestDrag = ReplicatedStorage.RemoteEvents:FindFirstChild("RequestStartDraggingItem")
                
                if campfire and items and requestDrag then
                    local firePos = campfire:GetPivot() + Vector3.new(0, 12, 0)
                    for _, item in pairs(items:GetChildren()) do
                        if item:IsA("Model") and item.PrimaryPart then
                            local name = item.Name
                            if name == "Log" or name == "Fuel Canister" or name == "Oil Barrel" or name == "Coal" then
                                pcall(function()
                                    requestDrag:FireServer(item)
                                    item:SetPrimaryPartCFrame(firePos)
                                end)
                                task.wait(0.02)
                            end
                        end
                    end
                else
                    task.wait(0.15)
                end
            end
        end)
        
        local campfire = getCampfire()
        if not campfire then
            Window:MakeNotification("Reveal Map Failed", "Campfire not found.", 3)
            _G.RevealMapRunning = false
            return
        end
        
        local firePart = campfire:FindFirstChild("Center") or campfire:FindFirstChildWhichIsA("BasePart")
        if not firePart then
            Window:MakeNotification("Reveal Map Failed", "Fire center missing.", 3)
            _G.RevealMapRunning = false
            return
        end
        
        local firePos = firePart.Position
        local character = getCharacter()
        local hrp = character:WaitForChild("HumanoidRootPart")
        
        local function smoothMove(targetPos, duration)
            local startPos = hrp.Position
            local steps = math.max(1, math.floor(duration / 0.016666666666666666))
            
            for i = 1, steps do
                if not _G.RevealMapRunning then return end
                local t = i / steps
                local smoothT = t * t * (3 - 2 * t)
                local newPos = startPos:Lerp(targetPos, smoothT)
                character:SetPrimaryPartCFrame(CFrame.new(newPos, firePos))
                RunService.Heartbeat:Wait()
            end
        end
        
        for radius = 200, 1400, 50 do
            if not _G.RevealMapRunning then break end
            
            for angle = 0, 315, 45 do
                local rad = math.rad(angle)
                local targetPos = Vector3.new(
                    firePos.X + math.cos(rad) * radius,
                    100,
                    firePos.Z + math.sin(rad) * radius
                )
                smoothMove(targetPos, 0.2)
                task.wait(0.03)
            end
            task.wait(0.25)
        end
        
        if _G.RevealMapRunning then
            Window:MakeNotification("Reveal Map", "Returning safely to campfire...", 3)
        else
            Window:MakeNotification("Reveal Map", "Reveal stopped early, returning...", 3)
        end
        
        local returnTween = TweenService:Create(hrp, TweenInfo.new(2.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            CFrame = CFrame.new(firePos + Vector3.new(0, 12, 0))
        })
        returnTween:Play()
        returnTween.Completed:Wait()
        
        _G.RevealMapRunning = false
        Window:MakeNotification("Reveal Map", " Map fully revealed  safely back at fire.", 3)
    end)
end

MiscSection:MakeToggle("Reveal Map", false, function(enabled)
    if enabled then
        revealMap()
    elseif _G.RevealMapRunning then
        _G.RevealMapRunning = false
        Window:MakeNotification("Reveal Map", "Stopping reveal safely...", 3)
    end
end)

local CollectionSection = Window:MakeSection("Collection")

local function teleportToItem(item)
    local hrp = getHRP()
    if hrp and item then
        local targetCFrame
        if item.GetPivot then
            targetCFrame = item:GetPivot()
        elseif item.PrimaryPart then
            targetCFrame = item.PrimaryPart.CFrame
        end
        if targetCFrame then
            hrp.CFrame = targetCFrame + Vector3.new(0, 3, 0)
        end
    end
end

CollectionSection:MakeButton("Collect All Coins", function()
    local collectCoins = ReplicatedStorage.RemoteEvents:FindFirstChild("RequestCollectCoins") or 
                        ReplicatedStorage.RemoteEvents:FindFirstChild("RequestCollectCoints")
    if collectCoins then
        local collected = 0
        for _, descendant in pairs(Workspace:GetDescendants()) do
            if descendant:IsA("Model") and (descendant.Name == "Coin Stack" or descendant:HasTag("Coins")) and 
               not descendant:GetAttribute("QueuedToTake") then
                task.spawn(function()
                    descendant:SetAttribute("QueuedToTake", true)
                    teleportToItem(descendant)
                    task.wait(0.2)
                    collectCoins:InvokeServer(descendant)
                    collected = collected + 1
                end)
                task.wait(0.1)
            end
        end
        Window:MakeNotification("Collect All Coins", "Collected " .. collected .. " coin stack(s).", 3)
    else
        Window:MakeNotification("Error", "Could not find collect coins remote!", 3)
    end
end)

CollectionSection:MakeButton("Collect All Flowers", function()
    local pickFlower = ReplicatedStorage.RemoteEvents:FindFirstChild("RequestPickFlower")
    if pickFlower then
        local collected = 0
        for _, descendant in pairs(Workspace:GetDescendants()) do
            if descendant:IsA("Model") and (descendant.Name == "Flower" or descendant:HasTag("Flower")) and 
               not descendant:GetAttribute("QueuedToTake") then
                task.spawn(function()
                    descendant:SetAttribute("QueuedToTake", true)
                    teleportToItem(descendant)
                    task.wait(0.25)
                    pickFlower:InvokeServer(descendant)
                    descendant:Destroy()
                    collected = collected + 1
                end)
                task.wait(0.15)
            end
        end
        Window:MakeNotification("Collect All Flowers", "Picked " .. collected .. " flower(s).", 3)
    else
        Window:MakeNotification("Error", "Could not find pick flower remote!", 3)
    end
end)

CollectionSection:MakeButton("Collect All Ammo", function()
    local consumeItem = ReplicatedStorage.RemoteEvents:FindFirstChild("RequestConsumeItem")
    if consumeItem then
        local items = Workspace:WaitForChild("Items")
        local collected = 0
        for _, item in pairs(items:GetChildren()) do
            if item:IsA("Model") and string.find(string.lower(item.Name), "ammo") then
                task.spawn(function()
                    teleportToItem(item)
                    task.wait(0.25)
                    consumeItem:InvokeServer(item)
                    collected = collected + 1
                end)
                task.wait(0.15)
            end
        end
        Window:MakeNotification("Auto Collect Ammo", "Collected " .. collected .. " ammo item(s).", 3)
    end
end)

CollectionSection:MakeToggle("Auto-Open Chests", false, function(enabled)
    autoOpenChestsEnabled = enabled
    if enabled then
        Window:MakeNotification("Auto-Open Chests", "Enabled  scanning every 5 seconds.", 3)
        autoOpenChestsThread = task.spawn(function()
            local firstScan = true
            while autoOpenChestsEnabled do
                local items = Workspace:FindFirstChild("Items")
                local opened = 0
                if items then
                    for _, item in pairs(items:GetChildren()) do
                        if item:IsA("Model") and string.find(item.Name, "Chest") then
                            pcall(function()
                                ReplicatedStorage.RemoteEvents.RequestOpenItemChest:FireServer(item)
                                opened = opened + 1
                            end)
                        end
                    end
                end
                if opened > 0 and not firstScan then
                    Window:MakeNotification("Auto-Open Chests", "Opened " .. opened .. " chest(s).", 3)
                end
                task.wait(5)
                firstScan = false
            end
        end)
    else
        if autoOpenChestsThread then
            task.cancel(autoOpenChestsThread)
            autoOpenChestsThread = nil
        end
        Window:MakeNotification("Auto-Open Chests", "Stopped scanning for new chests.", 3)
    end
end)

CollectionSection:MakeButton("Safe Zone", function()
    Window:MakeNotification("Safe Zone", "Loading model...", 3)
    task.spawn(function()
        for _, obj in pairs(Workspace:GetChildren()) do
            if obj.Name == "Axom_SafeZone" or obj.Name == "SafeZonePlatform" then
                obj:Destroy()
            end
        end

        local success, model = pcall(function()
            return game:GetObjects("rbxassetid://136466815865425")[1]
        end)

        if success and model then
            model.Name = "Axom_SafeZone"
            model.Parent = Workspace

            local basePart = model:FindFirstChild("BasePart")
            if basePart and basePart:IsA("BasePart") then
                model.PrimaryPart = basePart
                local hrp = getHRP()
                if hrp then
                    local position = hrp.Position + Vector3.new(0, 200, 0)
                    local cframe = CFrame.new(position) * CFrame.Angles(0, math.rad(-26.1756554), 0)
                    
                    for _, descendant in pairs(model:GetDescendants()) do
                        if descendant:IsA("BasePart") then
                            descendant.Anchored = true
                        end
                    end
                    
                    model:SetPrimaryPartCFrame(cframe)
                    
                    local platform = Instance.new("Part")
                    platform.Name = "SafeZonePlatform"
                    platform.Anchored = true
                    platform.CanCollide = true
                    platform.Transparency = 1
                    platform.Size = Vector3.new(50, 1, 50)
                    platform.CFrame = cframe * CFrame.new(0, -5, 0)
                    platform.Parent = Workspace
                    
                    task.wait(0.5)
                    hrp.CFrame = cframe * CFrame.new(0, 3, 0)
                    Window:MakeNotification("Safe Zone", " Spawned upright, flat, and rotated correctly!", 3)
                end
            else
                Window:MakeNotification("Safe Zone", " Model missing BasePart PrimaryPart.", 3)
            end
        else
            Window:MakeNotification("Safe Zone", " Failed to load asset.", 3)
        end
    end)
end)

RunService.Heartbeat:Connect(function()
    local char = player.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            if humanoid.WalkSpeed ~= walkSpeed then
                humanoid.WalkSpeed = walkSpeed
            end
            if humanoid.JumpPower ~= jumpPower then
                humanoid.JumpPower = jumpPower
            end
        end
    end
    
    if infiniteJump then
        local hrp = getHRP()
        if hrp then
            local humanoid = hrp.Parent and hrp.Parent:FindFirstChild("Humanoid")
            if humanoid and UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end
    
    if autoTeleportEnabled then
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health < healthThreshold then
                local map = Workspace:FindFirstChild("Map")
                if map then
                    local campground = map:FindFirstChild("Campground")
                    if campground then
                        local mainFire = campground:FindFirstChild("MainFire")
                        if mainFire then
                            safeTeleport(mainFire)
                        end
                    end
                end
            end
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and flyEnabled and not touchEnabled then
        if input.KeyCode == Enum.KeyCode.W then flyKeys.W = flySpeed
        elseif input.KeyCode == Enum.KeyCode.S then flyKeys.S = -flySpeed
        elseif input.KeyCode == Enum.KeyCode.A then flyKeys.A = -flySpeed
        elseif input.KeyCode == Enum.KeyCode.D then flyKeys.D = flySpeed
        elseif input.KeyCode == Enum.KeyCode.E then flyKeys.E = flySpeed * 2
        elseif input.KeyCode == Enum.KeyCode.Q then flyKeys.Q = -flySpeed * 2 end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if flyEnabled and not touchEnabled then
        if input.KeyCode == Enum.KeyCode.W then flyKeys.W = 0
        elseif input.KeyCode == Enum.KeyCode.S then flyKeys.S = 0
        elseif input.KeyCode == Enum.KeyCode.A then flyKeys.A = 0
        elseif input.KeyCode == Enum.KeyCode.D then flyKeys.D = 0
        elseif input.KeyCode == Enum.KeyCode.E then flyKeys.E = 0
        elseif input.KeyCode == Enum.KeyCode.Q then flyKeys.Q = 0 end
    end
end)

task.spawn(function()
    pcall(function()
        setclipboard("https://discord.gg/cuYwaQeHT5")
        Window:MakeNotification("Discord Link Copied", "Invite copied to clipboard.", 3)
    end)
end)

Window:MakeNotification("Script Loaded", "Axomic 99 Nights Hub - ALL features loaded successfully!", 5)
